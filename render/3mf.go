package render

import (
	"archive/zip"
	"encoding/xml"
	"fmt"
	"os"
	"strconv"

	"gonum.org/v1/gonum/spatial/r3"
)

const (
	unitMillimeter = "millimeter"
	xmlSchema      = "http://schemas.microsoft.com/3dmanufacturing/core/2015/02"
	xmlModelSchema = "http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel"
	modelFile      = "3D/3dmodel.model"
)

var (
	libMetadata = modelMetadata{
		Name:        "generator",
		Description: "Generated by github.com/drummonds/sdf. Please report bugs.",
	}
)

// Create3MF saves Renderer stream to a 3MF file type.
// This function is in experimental stage and may not work
// properly for large models.
func Create3MF(filename string, r Renderer) error {
	t, err := RenderAll(r)
	if err != nil {
		return err
	}
	mf := new3MF([]modelMetadata{
		{Name: "author", Description: "anonymous"},
	})
	err = mf.AddObject("SDFMesh", t)
	if err != nil {
		fmt.Println("file generated may be corrupt or not be manifold:", err)
	}

	return mf.Create(filename)
}

func new3MF(metadata []modelMetadata) model {
	return model{
		Schema:  xmlSchema,
		XMLLang: "en-US",
		Unit:    unitMillimeter,
		Metadata: append(metadata, libMetadata, modelMetadata{
			Name:        "Title",
			Description: "SDF",
		}),
	}
}

type model struct {
	XMLName xml.Name `xml:"model"`
	// i.e. "millimeter"
	Unit string `xml:"unit,attr"`
	// Usually en-US
	XMLLang string `xml:"xml:lang,attr"`
	// Usually http://schemas.microsoft.com/3dmanufacturing/core/2015/02
	Schema    string          `xml:"xmlns,attr"`
	Metadata  []modelMetadata `xml:"metadata"`
	Resources resources       `xml:"resources"`
	Build     []item          `xml:"build>item"`
}

type resources struct {
	Objects []mf3object `xml:"object"`
}

type item struct {
	ObjectID  int    `xml:"objectid,attr"`
	Transform string `xml:"transform,attr,omitempty"`
}

type modelMetadata struct {
	Name        string `xml:"name,attr"`
	Description string `xml:",chardata"`
}

type mf3object struct {
	ID         int     `xml:"id,attr"`
	Name       string  `xml:"name,attr"`
	PartNumber string  `xml:"partnumber,attr"`
	PID        int     `xml:"pid,attr"`
	PIndex     int     `xml:"pindex,attr"`
	Type       string  `xml:"type,attr"`
	Mesh       mf3Mesh `xml:"mesh"`
}

type mf3Mesh struct {
	Vertices  []mf3Vertex   `xml:"vertices>vertex"`
	Triangles []mf3Triangle `xml:"triangles>triangle"`
}

type mf3Vertex struct {
	X float64 `xml:"x,attr"`
	Y float64 `xml:"y,attr"`
	Z float64 `xml:"z,attr"`
}

type mf3Triangle struct {
	V1 int `xml:"v1,attr"`
	V2 int `xml:"v2,attr"`
	V3 int `xml:"v3,attr"`
}

func (m *model) AddObject(name string, src []Triangle3) error {
	id := len(m.Resources.Objects) + 1
	type vertexEntry struct {
		idx   int
		count int
	}
	dst := make([]mf3Triangle, len(src))
	vertexMap := make(map[r3.Vec]vertexEntry)
	vertices := make([]mf3Vertex, 0, len(src)*3)
	for it, t := range src {
		for i := 0; i < 3; i++ {
			vertex := t.V[i]
			entry, ok := vertexMap[vertex]
			if !ok {
				entry = vertexEntry{
					idx:   len(vertices),
					count: 1,
				}
				vertices = append(vertices, mf3Vertex(vertex))
			} else {
				entry.count++
			}
			vertexMap[vertex] = entry
			switch i {
			case 0:
				dst[it].V1 = entry.idx
			case 1:
				dst[it].V2 = entry.idx
			case 2:
				dst[it].V3 = entry.idx
			}
		}
	}

	m.Resources.Objects = append(m.Resources.Objects,
		mf3object{
			ID:         id,
			Name:       name,
			Type:       "model",
			PartNumber: name + "-" + strconv.Itoa(id),
			Mesh: mf3Mesh{
				Vertices:  vertices,
				Triangles: dst,
			},
		},
	)
	m.Build = append(m.Build, item{
		ObjectID:  id,
		Transform: "", // no transform
	})
	for vertex, data := range vertexMap {
		if data.count < 3 {
			return fmt.Errorf("vertex %+v shared by less than 3 triangles", vertex)
		}
	}
	return nil
}

func (m *model) Create(filename string) error {
	fp, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer fp.Close()
	w := zip.NewWriter(fp)
	defer w.Close()
	f, err := w.Create(modelFile)
	if err != nil {
		return err
	}
	_, err = f.Write([]byte(xml.Header))
	if err != nil {
		return err
	}
	e := xml.NewEncoder(f)
	e.Indent("", "\t")
	err = e.Encode(m)
	if err != nil {
		return err
	}
	rels, err := w.Create("_rels/.rels")
	if err != nil {
		return err
	}
	_, err = rels.Write([]byte(xml.Header))
	if err != nil {
		return err
	}
	e = xml.NewEncoder(rels)
	e.Indent("", "\t")
	err = e.Encode(m.relationships())
	if err != nil {
		return err
	}
	ct, err := w.Create("[Content_Types].xml")
	if err != nil {
		return err
	}
	_, err = ct.Write([]byte(mf3Content))
	if err != nil {
		return err
	}
	// Make sure to check the error on Close.
	return w.Close()
}

func (m *model) relationships() interface{} {
	type Relationship struct {
		Target string `xml:",attr"`
		ID     string `xml:"Id,attr"`
		Type   string `xml:",attr"`
	}
	type Relationships struct {
		Schema       string         `xml:"xmlns,attr"`
		Relationship []Relationship `xml:"Relationship"`
	}
	return Relationships{
		Schema: "http://schemas.openxmlformats.org/package/2006/relationships",
		Relationship: []Relationship{
			{
				Target: modelFile,
				Type:   xmlModelSchema,
				ID:     "rel0",
			},
		},
	}
}

const mf3Content = `<?xml version="1.0" encoding="utf-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
	<Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />
	<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
</Types>`
